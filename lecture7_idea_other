#!/usr/bin/env python3
"""
Minimal terminal Minesweeper
----------------------------
* Input coordinates as:  row col   (1-based integers; e.g., "3 5")
* q to quit
* Win by revealing all non-mine squares.
"""

import random


class Minesweeper:
    def __init__(self, rows=9, cols=9, mines=10, seed=None):
        if mines >= rows * cols:
            raise ValueError("Number of mines must be less than total cells.")
        self.rows = rows
        self.cols = cols
        self.mines = mines
        if seed is not None:
            random.seed(seed)

        # board data
        self._mine = [[False]*cols for _ in range(rows)]
        self._count = [[0]*cols for _ in range(rows)]   # adjacent mine counts

        # player view: False=hidden, True=revealed
        self._revealed = [[False]*cols for _ in range(rows)]

        self._game_over = False
        self._won = False

        self._place_mines()
        self._compute_counts()
        self._remaining_safe = rows*cols - mines  # unrevealed safe squares

    # ----- setup helpers -----
    def _place_mines(self):
        cells = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        for r, c in random.sample(cells, self.mines):
            self._mine[r][c] = True

    def _neighbors(self, r, c):
        for rr in range(max(0, r-1), min(self.rows, r+2)):
            for cc in range(max(0, c-1), min(self.cols, c+2)):
                if rr == r and cc == c:
                    continue
                yield rr, cc

    def _compute_counts(self):
        for r in range(self.rows):
            for c in range(self.cols):
                if self._mine[r][c]:
                    self._count[r][c] = -1
                else:
                    self._count[r][c] = sum(self._mine[rr][cc] for rr, cc in self._neighbors(r, c))

    # ----- gameplay -----
    def reveal(self, r, c):
        """Reveal cell (r,c) 0-based. Returns status string."""
        if self._game_over:
            return "Game already over."
        if not (0 <= r < self.rows and 0 <= c < self.cols):
            return "Out of range."
        if self._revealed[r][c]:
            return "Already revealed."

        if self._mine[r][c]:
            self._game_over = True
            self._revealed[r][c] = True
            return "BOOM! You hit a mine."

        # flood fill for zeros
        self._flood_reveal(r, c)
        if self._remaining_safe == 0:
            self._game_over = True
            self._won = True
            return "You cleared the field! You win!"
        return "Revealed."

    def _flood_reveal(self, r, c):
        """Reveal reachable safe region starting at (r,c)."""
        stack = [(r, c)]
        while stack:
            rr, cc = stack.pop()
            if self._revealed[rr][cc]:
                continue
            self._revealed[rr][cc] = True
            self._remaining_safe -= 1
            if self._count[rr][cc] == 0:
                for nrr, ncc in self._neighbors(rr, cc):
                    if not self._revealed[nrr][ncc] and not self._mine[nrr][ncc]:
                        stack.append((nrr, ncc))

    # ----- rendering -----
    def board_string(self, reveal_mines=False):
        """Return printable string of current board state."""
        # column header
        header_nums = "  " + "".join(f"{c+1:2d}" for c in range(self.cols))
        lines = [header_nums]

        for r in range(self.rows):
            row_cells = []
            for c in range(self.cols):
                ch = self._cell_char(r, c, reveal_mines)
                row_cells.append(ch)
            line = f"{r+1:2d} " + " ".join(row_cells)
            lines.append(line)
        return "\n".join(lines)

    def _cell_char(self, r, c, reveal_mines):
        if self._revealed[r][c]:
            if self._mine[r][c]:
                return "*"
            cnt = self._count[r][c]
            return str(cnt) if cnt > 0 else " "
        # hidden
        if self._game_over and reveal_mines and self._mine[r][c]:
            return "*"
        return "#"

    # ----- user loop -----
    def play(self):
        print(f"=== Minesweeper {self.rows}x{self.cols}, {self.mines} mines ===")
        while not self._game_over:
            print(self.board_string())
            move = input("Enter row col (q to quit): ").strip().lower()
            if move in ("q", "quit", "exit"):
                print("Bye!")
                return
            try:
                r_str, c_str = move.split()
                r = int(r_str) - 1
                c = int(c_str) - 1
            except Exception:
                print("Format: row col  (e.g., 3 5)")
                continue

            msg = self.reveal(r, c)
            print(msg)
            print()

        # final board
        print(self.board_string(reveal_mines=True))
        if self._won:
            print("ðŸŽ‰  You win!")
        else:
            print("ðŸ’£  Game over.")


def main():
    # Change size/mines here if you like:
    game = Minesweeper(rows=9, cols=9, mines=10)
    game.play()


if __name__ == "__main__":
    main()
